# 2018 Round B

-   Score : -
-   Rank : -

---

## A

- 数位DP

## B

- 考虑字典序对应的唯一做法——贪心
- 那么我们需要从前向后贪心，每一位优先取0，如果可行方案太少就取1，细节见代码
- 现在问题变为如何动态维护可行方案
- 我们预先从后向前`dp[i][mask]`表示从第$i$位开始的连续16位为mask，同时满足第$i$位以后的所有约束的方案数
- 考虑前面位置的确定对后面的方案数肯定有影响，我们如何量化这种影响呢？
- 就是把约束给传递下去！
- 例如当前约束为第$i$到$j$位中需要有$k$个$1$，在确定了第$i$位后，我们可以将约束转化为
    从第$i + 1$位到第$j$位需要$k - ans[i]$个$1$
- 然后基于预处理的后缀dp数组重新计算方案数即可
- 考虑到每个约束最多出现长度次，总约束个数不超过$16 * 100$个
- P.S. $B_i - A_i \leq 15$，我就傻傻地只缓存了15位的mask，晕了= =

## C

- 直接数可行方案数不好弄，我们看看不可行是什么情况
  
- 画一画就发现，不可行就是$H_i < H_j < H_k$，同时满足($V_i < V_j < V_k$或$V_i > V_j > V_k$)
  
- 这就简单了，数两遍三维逆序对就可以了
  
  ​    
  
